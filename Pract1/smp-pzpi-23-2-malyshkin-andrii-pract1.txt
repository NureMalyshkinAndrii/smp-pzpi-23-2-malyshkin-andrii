                        МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
              ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



                            Кафедра Програмної інженерії




                                        Звіт
                              з практичної роботи № 1
                    з дисципліни: «Скриптові мови програмування»
     з теми: «Розробка інженерного рішення для друкування ялинки мовою Bash
               (Bourne again shell) з використанням циклів та галужень»




Виконав:                                                                  Перевірив:
ст. гр. ПЗПІ-23-2                                                  ст. викл. каф. ПІ
Малишкін А. С.                                                         Сокорчук І. П.




                                   Харків – 2025
                                                                                   2
             1 РОЗРОБКА ІНЖЕНЕРНОГО РІШЕННЯ ДЛЯ ДРУКУВАННЯ ЯЛИНКИ
            МОВОЮ BASH (BOURNE AGAIN SHELL) З ВИКОРИСТАННЯМ ЦИКЛІВ
                                    ТА ГАЛУЖЕНЬ
1.1 Мета роботи

         Здобути навички створення сценаріїв автоматизації засобами Bash (Bourne
   again shell).

1.2 Хід роботи

         Метою роботи є створення сценарію мовою Bash, що друкуватиме на екрані
   ялинку із двох ярусів гілок, стовбура та шару снігу.

         1.2.1 Вимоги до сценарію

         Згідно до завдання до сценарію є наступні умови:

          а) ялинка повинна бути симетричною;
         б) яруси гілок повинні утворювати правильні рівнобедрені трикутники у
              яких сусідні рядки відрізняються на два символи та складаються
              почергово або з символів «*» або з символів «#»;
         в)   ширина усіх ярусів гілок повинна бути на 2 символи вужча ніж ширина
              снігу;
          г) висота стовбура повинна бути 2 рядки, а ширина 3 стовбці;
          д) висота шару снігу повинна бути 1 рядок;
         е) висота ялинки у рядках разом з шаром снігу та ширина шару снігу в
              символах вказується сценарію в його параметрах при запуску;
         ж) параметри сценарію повинні мати додатнє значення;
          и) вказані значення повинні округлятися до потрібних у меншу сторону;
         к) якщо за вказаними при запуску сценарія значеннями зобразити ялинку на
              екрані неможливо, скрипт повинен вивести у потік помилок сповіщення
              про неправильне значення аргумента і повернути відповідний результат
              у батьківський процес;
         л)   у сценарії потрібно обов’язково використати функцію та такі
              конструкції;
                                                                                       3
1)   if ... then ... fi

2)   while ... do ... done

3)   until ... do ... done

4)   for ... in .. do ... done

5)   for ((...)); do ... done

          м)    файл    сценарію   повинен   бути   виконуваним    файлом    для   усіх
                користувачів системи;
          н) право редагувати файл сценарію повинен мати лише власник.

          1.2.2 Створимо сценарій дотримуючись вимог

          Щоб сценарій, написаний мовою Bash, був зручнішим у використанні, він
     повинен починатися з Шебангу (Shebang) — спеціальної послідовності символів
     #!, після якої вказується шлях до інтерпретатора. Ця послідовність дозволяє
     системі правильно розпізнати та виконати файл як програму. Коли сценарій
     запускається, операційна система використовує зазначений інтерпретатор для
     його виконання. У нашому випадку вкажемо шлях до Bash: /bin/bash.
          Перш за все сценарій має виконати валідацію та нормалізацію аргументів.
                  Серед вимог до сценарію є наступні обмеження аргументів:
          а) кількість аргументів має дорівнювати 2;
          б) мінімальна висота ялинки складає 8 рядків. А саме – 1 рядок для шару
                снігу, 2 рядки для стовбура, 1 рядок для верхівки та 4 рядків для гілок
                (по 2 на кожен з ярусів);
          в) мінімальна ширина шару снігу складає 7 символів – це на 2 більше, ніж
                ширина гілок найменшої можливої ялинки.
          г) ширина снігу після нормалізації значень аргументів повинна бути
                більшою за ширину гілок ялинки рівно на 2 символи.
          Спочатку перевіряємо, чи передано рівно два аргументи, інакше виводимо
     повідомлення про помилку та завершуємо виконання сценарію:
          if (( $# != 2 )); then
               echo "Not enough/Too many arguments" >&2
               exit 1
          fi
                                                                              4
     Далі перевіряємо, чи задана висота ялинки не менша за 8. Якщо вона менша,
виводимо повідомлення та завершуємо виконання сценарію:
     if (( $1 < 8 )); then
       echo "Height should be > 7" >&2
       exit 2
     fi
     Аналогічно перевіряємо мінімальну ширину шару снігу, яка має бути не
менше 7 символів:
     if (( $2 < 7 )); then
       echo "Width should be > 6" >&2
       exit 3
     fi
     Далі коригуємо висоту та ширину, щоб вони відповідали вимогам до
правильної побудови:
     tree_height=$(( (($1 - 4) % 2 != 0) ? $1 - 1 : $1 ))
     snow_width=$(( ($2 % 2 == 0) ? $2 - 1 : $2 ))
     leaf_rows=$(( (tree_height - 1) / 2 ))
     Остання перевірка гарантує, що ширина шару снігу після нормалізації
більша за ширину гілок рівно на 2 символи. Якщо умова не виконується, сценарій
завершується з помилкою:
     if (( snow_width - (2 * leaf_rows - 1) != 2 )); then
       echo "Can't draw the tree with provided arguments" >&2
       exit 4
     fi
     Після перевірок ми налаштовуємо значення висоти ялинки та ширини снігу.
Використовуємо арифметичні операції, щоб коригувати висоту до найближчого
парного числа, якщо це необхідно. Ширина снігу коригується так, щоб вона була
непарною, і завжди на два символи більша за ширину ялинки.
     Для побудови самої ялинки використовуємо функцію draw_leaves. Вона
відповідає за малювання одного з ярусів гілок ялинки. У цій функції ми по черзі
будуємо кожен рядок гілок. Визначаємо кількість пробілів для вирівнювання, а
також міняємо символи між # і * кожного рядка. Оскільки ми маємо два яруси, ми
викликаємо цю функцію двічі, кожен раз з відповідними параметрами для
верхнього та нижнього ярусів.
                                                                         5
     Наступною є функція draw_trunk, яка відповідає за малювання стовбура
ялинки. Ми використовуємо стандартну конструкцію циклу для побудови двох
однакових рядків, що формують стовбур. Висота стовбура завжди фіксована —
два рядки по три символи #. Для кожного рядка стовбура визначаємо, скільки
пробілів потрібно для правильного вирівнювання.
     Нарешті, ми реалізуємо функцію draw_snow, яка будує останній рядок —
шар снігу. У цій функції простим циклом ми генеруємо рядок з зірочок і виводимо
його на екран.
     Всі функції викликаються послідовно: спочатку малюємо яруси, потім
стовбур, і на завершення – шар снігу. Використання таких конструкцій як for,
while, until дозволяє гнучко реалізувати логіку побудови кожного елементу
ялинки. Наприклад, цикл until в функції draw_leaves відповідає за побудову
кожного символу в рядку з потрібною кількістю символів, які чергуються.
     Перевіримо створений сценарій за допомогою заготованої програми
перевірки:
     Обліковий запис: pzpi-23-2-malyshkin-andrii
     Скрипт: /home/pzpi-23-2-malyshkin-andrii/pzpi-23-2-malyshkin-an
     drii-     task1.sh
     ---
     Перевірка встановлених прав доступу до файла скрипта (-rwxr-xr-x
     див.      завдання):
     ПЕРЕВІРЕНО!
     ---
     Перевірка розміру файла скрипта:
     ПЕРЕВІРЕНО!
     ---
     Перевірка першого рядка Bash скрипта:
     ПЕРЕВІРЕНО! Перший рядок скрипта: #!/bin/bash
     ---
     Перевірка загального синтаксису скрипта:
     ПЕРЕВІРЕНО!
     ---
     Перевірка використаних синтаксичних констркцій Bash:
     ПЕРЕВІРЕНО! Конструкція: if ...; then ...; fi
     ПЕРЕВІРЕНО! Конструкція: while ...; do ...; done
     ПЕРЕВІРЕНО! Конструкція: until ...; do ...; done
     ПЕРЕВІРЕНО! Конструкція: for ... in ...; do ...; done
     ПЕРЕВІРЕНО! Конструкція: for ((...)); do ... done
     ПЕРЕВІРЕНО! Конструкція: function ...() { ... }
     ---
     Перевірка скрипта статичним аналізатором коду:
     ПЕРЕВІРЕНО!
                                                                        6
      ---
      Перевірка роботи скрипта (приклад див.: pzpi23-task1_example):
      ---
      РЕЗУЛЬТАТИ ПЕРЕВІРКИ
      УСПІШНИХ ТЕСТІВ: 14
      НЕВДАЛИХ ТЕСТІВ: 0
      ПРАВИЛЬНИЙ STDOUT:      625
      НЕПРАВИЛЬНИЙ STDOUT:    0
      ПРАВИЛЬНИЙ EXIT_CODE:   625
      НЕПРАВИЛЬНИЙ EXIT_CODE: 0
      ПРАВИЛЬНИЙ STDERR:      625
      НЕПРАВИЛЬНИЙ STDERR:    0
      ---
      ОЦІНКА ЗА КОД: 100 ( /home/pzpi-23-2-malyshkin-andrii/pzpi-23-2-
      malyshkin-andrii-task1.sh без перевірки на плагіат )




      1.3 Висновки

     Під час виконання даної практичної роботи набуто навичок створювати
сценарії автоматизації засобами Bash (Bourne again shell).
                                                               7
                             ДОДАТОК А
                   Повний текст розробленого сценарію

#!/bin/bash

if (( $# != 2 )); then
 echo "Not enough/Too many arguments" >&2
   exit 1
fi

if (( $1 < 8 )); then
   echo "Height should be greater then 7" >&2
   exit 2
fi
if (( $2 < 7 )); then
   echo "Width should be greater then 6" >&2
   exit 3
fi

tree_height=$(( (($1 - 4) % 2 != 0) ? $1 - 1 : $1 ))
snow_width=$(( ($2 % 2 == 0) ? $2 - 1 : $2 ))
leaf_rows=$(( (tree_height - 1) / 2 ))

if (( snow_width - (2 * leaf_rows - 1) != 2 )); then
   echo "Can't draw the tree with provided arguments" >&2
   exit 4
fi

current_char='#'

draw_leaves() {
  local start_line=$1
  local end_line=$leaf_rows
  for (( line = start_line; line <= end_line; line++ )); do
    if [ "$current_char" = "*" ]; then
       current_char="#"
    else
       current_char="*"
    fi
    local num_chars=$(( 2 * line - 1 ))
    local spaces=$(( (snow_width - num_chars) / 2 ))
    printf "%${spaces}s" ""
    local row=""
    local count=$num_chars
    until (( count <= 0 )); do
       row="${row}${current_char}"
       count=$(( count - 1 ))
    done
    printf "%s\n" "$row"
  done
                                             8
}

draw_trunk() {
  local trunk_line=""
  for seg in 1 2 3; do
    trunk_line="${trunk_line}#"
  done
  for (( i = 0; i < 2; i++ )); do
    local pad=$(( (snow_width - 3) / 2 ))
    printf "%${pad}s" ""
    printf "%s\n" "$trunk_line"
  done
}

draw_snow() {
  local snow_line=""
  local pos=0
  while (( pos < snow_width )); do
    snow_line="${snow_line}*"
    pos=$(( pos + 1 ))
  done
  printf "%s\n" "$snow_line"
}

tier=1
while (( tier <= 2 )); do
  if (( tier == 1 )); then
     draw_leaves 1
  else
     draw_leaves 2
  fi
  tier=$(( tier + 1 ))
done

draw_done=0
until (( draw_done == 1 )); do
  draw_trunk
  draw_done=1
done

draw_snow